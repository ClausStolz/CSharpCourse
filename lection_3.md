# Лекция 3
## Операции над типами

### **1. Преобразование числовых типов в другие числовые типы**

Нужно понимать, что в языке C# целочисленные преобразования выполняются неявно, если тип может представить все возможные значения исходного типа.
```
int x = 12345;
long y = x; //неявное преобразование
short z = (short)x; //явное преобразование
```

В случае же с вещественными типами, тип `double` может содержать все значения типа `float`, поэтому преборазование из `float` в `double` может быть неявным, обратное же действие должно быть явным.
Если рассмотривать тип `decimal` он включает в себя все другие вещественные типы, и поэтому преобразование из него в другие типы должно быть явным.

### **2. Арифметические операторы**
Язык C# имеет стандартные арифметические операторы `+, -, *, /`, также он имеет оператор целочисленного деления `//` и остаток от деления `%`.

Кроме этого есть унарные операции инкремента и декримента и унарного минуса.
**Для самых маленьких**
> Унарная операция - операция, которая содержит один операнд.

> Бинарная операция - операция, которая содержит два операнда.

В чем их суть?
1. Инкремент - увеличивает значение на единицу `x++`
2. Декримент - уменьшает значение на единицу `x--`

Данные унарные функции можно записывать с разных сторон. От этого будет зависеть полученный результат. Так, рассмотрим на примере инкримента две записи
1. Префиксная запись
```
int y = ++x;

//аналогично
x = x + 1;
int y = x;
```
2. Постфиксная запись (также говорят суффиксная запись)
```
int y = x++;

//аналогично
int y = x;
x = x + 1;
```

Язык C# очень лоялен к программисту, поэтому переполнение происходит незаметно. Для того, чтобы получать ошибку переполнения `OverflowException`, для операций, которые могут вызвать переполнение нужно использовать операцию `checked`
```
int a = 100000;
int b = 100000;
int c = checked(a * b);
//компилятор вернет ошибку OverflowException
```
## **Очень важно**
Стоит обратить внимание, что при округлении действительных типов происходят ошибки. Это вызвано тем, что тип `float` и `double` хранятся в компьютере в двоичном виде. Поэтому литералы с дробной частью невозможно представить точно. Поэтому для расчетов, когда для нас объем затраченной памяти незначителен лучше всего использовать тип `decimal`.

### 3. **Условные операторы**
Стоит затронуть булевые операции - это такие операции, которые в результате возвращают нам одно из двух значений: `True` `False`.
Так у нас есть две операции сравнения - `==, !=`, проверяющие равенство и неравенство соответсвенно.

Также мы имеем операторы сравнения - `>, >=, <, <=`. Данные операторы полностью повторяют поведение обычных арфиметических операторов сравнения.

Кроме всего прочего есть условные операторы: `&&`- и , `||`- или, `!`- не (отрицание).

Думаю, для демонстрации их работы досаточен обычный пример (*если данные операции вызывают у вас большие сложности, стоит обратиться к курсу школьной информатики и восполнить недостающий фундаментальные знания*)
```
Console.WriteLine(12 == 13); //False
Console.WriteLine(12 != 13); //True
Console.WriteLine(12 <= 13); //True
Console.WriteLine(12 > 12); //False
Console.WriteLine(!True); //False
```
